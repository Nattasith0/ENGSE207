# การเปรียบเทียบ Monolithic และ Layered Architecture (ENGSE207)

---

## คำถาม 1: การเปรียบเทียบโครงสร้าง (5 คะแนน)

### ก. จำนวนบรรทัดโค้ดและไฟล์

| ข้อมูล             | Monolithic (Week 3)           | Layered (Week 4)                                           |
| ------------------ | ----------------------------- | ---------------------------------------------------------- |
| จำนวนไฟล์ JS หลัก  | 1–2 ไฟล์ (server.js เป็นหลัก) | หลายไฟล์ (controller, service, repository, middleware ฯลฯ) |
| จำนวนบรรทัดทั้งหมด | น้อยกว่า (~200–300 บรรทัด)    | มากกว่า (~400–600 บรรทัด)                                  |
| จำนวน layers       | 1 layer                       | 3–4 layers (Controller, Service, Data, Middleware)         |
| ความซับซ้อนโดยรวม  | ต่ำ                           | สูงกว่า                                                    |

### คำถาม

**1.Layered มีจำนวนไฟล์และบรรทัดโค้ดมากกว่าหรือน้อยกว่า Monolithic? เพราะอะไร?**

Layered Architecture มีจำนวนไฟล์และบรรทัดโค้ดมากกว่า Monolithic เนื่องจากมีการแยกความรับผิดชอบของโค้ดออกเป็นแต่ละชั้น (Layer) เช่น Controller, Service และ Data Access ทำให้โค้ดไม่ถูกรวมอยู่ในไฟล์เดียว

**2.ความซับซ้อนที่เพิ่มขึ้นคุ้มค่าหรือไม่? อธิบาย**

ความซับซ้อนที่เพิ่มขึ้นถือว่าคุ้มค่าในระยะยาว เพราะทำให้โค้ดดูแลง่าย แก้ไขง่าย และรองรับการขยายระบบได้ดีกว่า Monolithic โดยเฉพาะในโปรเจกต์ขนาดกลางถึงใหญ่

---

## คำถาม 2: จุดแข็ง-จุดอ่อน (10 คะแนน)

| Quality Attribute  | Monolithic | Layered | คะแนน (1-5) | อธิบายเหตุผล                               |
| ------------------ | ---------- | ------- | ----------- | ------------------------------------------ |
| Maintainability    | ต่ำ        | สูง     | 4           | Layered แยก logic ชัดเจน แก้ไขเฉพาะส่วนได้ |
| Testability        | ต่ำ        | สูง     | 4           | สามารถทดสอบ Service หรือ Controller แยกได้ |
| Modifiability      | ต่ำ        | สูง     | 4           | เพิ่ม feature ใหม่โดยไม่กระทบส่วนอื่น      |
| Reusability        | ต่ำ        | สูง     | 4           | Service และ Utility สามารถนำกลับมาใช้ซ้ำ   |
| Team Collaboration | ต่ำ        | สูง     | 5           | ทีมสามารถแยกกันทำแต่ละ layer ได้           |
| Performance        | สูง        | กลาง    | 3           | Layered มี overhead จากการเรียกหลายชั้น    |
| Simplicity         | สูง        | ต่ำ     | 2           | Monolithic เข้าใจง่ายกว่าในโปรเจกต์เล็ก    |

---

## คำถาม 3: สถานการณ์จริง (5 คะแนน)

### สถานการณ์ที่ 1: เพิ่มฟีเจอร์ "assign task to user"

**Monolithic:**

* แก้ไข server.js โดยตรง
* เพิ่ม field userId และ logic ในไฟล์เดียว

**Layered:**

* เพิ่ม field ใน Model/Repository
* เพิ่ม logic ใน Service
* เพิ่ม API ใน Controller

**สรุป:** Layered ง่ายกว่าในระยะยาว เพราะโครงสร้างรองรับการขยาย

---

### สถานการณ์ที่ 2: บั๊กที่ validation logic (title ว่าง)

**Monolithic:**

* ต้องไล่หา validation logic ในไฟล์ใหญ่

**Layered:**

* ตรวจสอบที่ Service หรือ Middleware โดยตรง

**สรุป:** Layered แก้บั๊กง่ายกว่า เพราะ logic อยู่เป็นจุดเดียว

---

### สถานการณ์ที่ 3: เปลี่ยนฐานข้อมูล SQLite → PostgreSQL

**Monolithic:**

* ต้องแก้หลายจุดที่มี SQL query

**Layered:**

* แก้เฉพาะ Data/Repository layer

**สรุป:** Layered ง่ายกว่าและปลอดภัยกว่า

---

## คำถาม 4: Trade-offs (5 คะแนน)

### Complexity vs Maintainability

Layered มีความซับซ้อนมากขึ้น แต่ทำให้ดูแลง่ายขึ้นในระยะยาว เหมาะกับโปรเจกต์ที่มีการพัฒนาต่อเนื่องหรือหลายคนทำร่วมกัน ไม่คุ้มค่าในโปรเจกต์เล็กหรือทดลอง

### Performance Overhead

Overhead จาก Layered มีผลน้อยมากในระบบทั่วไป แต่จะสำคัญในระบบ real-time หรือ high-performance เช่น game server หรือ streaming

---

## คำถาม 5: การตัดสินใจเลือกใช้ (5 คะแนน)

### Decision Tree

```
เริ่มต้นโปรเจกต์
│
├─ ขนาดทีม?
│  ├─ 1-2 คน → Monolithic (โค้ดน้อย เร็ว)
│  └─ 3+ คน → Layered (แบ่งงานง่าย)
│
├─ ขนาดโปรเจกต์?
│  ├─ เล็ก (< 1000 บรรทัด) → Monolithic
│  ├─ กลาง (1000-10000 บรรทัด) → Layered
│  └─ ใหญ่ (> 10000 บรรทัด) → Layered
│
├─ ระยะเวลาพัฒนา?
│  ├─ ต้องการเร็ว (< 1 เดือน) → Monolithic
│  └─ มีเวลา (> 1 เดือน) → Layered
│
└─ ต้องการ maintainability สูง?
   ├─ ใช่ → Layered
   └─ ไม่ → Monolithic
```

### เหตุผล

* Monolithic เหมาะกับงานเล็ก เร็ว และทีมเล็ก
* Layered เหมาะกับงานที่ต้องดูแลระยะยาว ขยายระบบ และทำงานเป็นทีม